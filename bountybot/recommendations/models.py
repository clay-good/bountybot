"""
Data models for the recommendation system.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Set
from uuid import uuid4


class RecommendationType(Enum):
    """Types of recommendations."""
    VALIDATION_STRATEGY = "validation_strategy"
    REMEDIATION_APPROACH = "remediation_approach"
    SECURITY_BEST_PRACTICE = "security_best_practice"
    CODE_FIX = "code_fix"
    WAF_RULE = "waf_rule"
    TESTING_APPROACH = "testing_approach"
    SIMILAR_VULNERABILITY = "similar_vulnerability"
    EXPLOIT_TECHNIQUE = "exploit_technique"
    MITIGATION_CONTROL = "mitigation_control"
    PRIORITY_ADJUSTMENT = "priority_adjustment"


class FeedbackType(Enum):
    """Types of feedback for recommendations."""
    ACCEPTED = "accepted"
    REJECTED = "rejected"
    MODIFIED = "modified"
    HELPFUL = "helpful"
    NOT_HELPFUL = "not_helpful"
    PARTIALLY_HELPFUL = "partially_helpful"


class PatternType(Enum):
    """Types of learned patterns."""
    VULNERABILITY_PATTERN = "vulnerability_pattern"
    REMEDIATION_PATTERN = "remediation_pattern"
    FALSE_POSITIVE_PATTERN = "false_positive_pattern"
    EXPLOIT_PATTERN = "exploit_pattern"
    CODE_PATTERN = "code_pattern"
    RESEARCHER_PATTERN = "researcher_pattern"


class EdgeType(Enum):
    """Types of edges in the knowledge graph."""
    SIMILAR_TO = "similar_to"
    CAUSES = "causes"
    MITIGATES = "mitigates"
    EXPLOITS = "exploits"
    FIXES = "fixes"
    RELATED_TO = "related_to"
    DEPENDS_ON = "depends_on"
    PART_OF = "part_of"


@dataclass
class RecommendationContext:
    """Context for generating recommendations."""
    vulnerability_type: str
    severity: str
    language: Optional[str] = None
    framework: Optional[str] = None
    codebase_context: Optional[Dict[str, Any]] = None
    historical_data: Optional[Dict[str, Any]] = None
    researcher_profile: Optional[Dict[str, Any]] = None
    validation_stage: Optional[str] = None
    current_findings: Optional[List[str]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Recommendation:
    """A recommendation generated by the system."""
    recommendation_id: str = field(default_factory=lambda: str(uuid4()))
    type: RecommendationType = RecommendationType.VALIDATION_STRATEGY
    title: str = ""
    description: str = ""
    confidence: float = 0.0  # 0.0 to 1.0
    reasoning: str = ""
    
    # Content
    content: Dict[str, Any] = field(default_factory=dict)
    code_snippet: Optional[str] = None
    references: List[str] = field(default_factory=list)
    
    # Context
    context: Optional[RecommendationContext] = None
    similar_cases: List[str] = field(default_factory=list)
    
    # Metadata
    created_at: datetime = field(default_factory=datetime.utcnow)
    source: str = "recommendation_engine"
    tags: List[str] = field(default_factory=list)
    priority: int = 0  # Higher is more important
    
    # Learning
    applied: bool = False
    feedback: Optional['RecommendationFeedback'] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'recommendation_id': self.recommendation_id,
            'type': self.type.value,
            'title': self.title,
            'description': self.description,
            'confidence': self.confidence,
            'reasoning': self.reasoning,
            'content': self.content,
            'code_snippet': self.code_snippet,
            'references': self.references,
            'similar_cases': self.similar_cases,
            'created_at': self.created_at.isoformat(),
            'source': self.source,
            'tags': self.tags,
            'priority': self.priority,
            'applied': self.applied,
        }


@dataclass
class RecommendationFeedback:
    """Feedback on a recommendation."""
    feedback_id: str = field(default_factory=lambda: str(uuid4()))
    recommendation_id: str = ""
    feedback_type: FeedbackType = FeedbackType.HELPFUL
    
    # Details
    user_id: str = ""
    comment: Optional[str] = None
    modified_content: Optional[Dict[str, Any]] = None
    
    # Metrics
    time_to_apply: Optional[float] = None  # Seconds
    effectiveness_score: Optional[float] = None  # 0.0 to 1.0
    
    # Metadata
    created_at: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'feedback_id': self.feedback_id,
            'recommendation_id': self.recommendation_id,
            'feedback_type': self.feedback_type.value,
            'user_id': self.user_id,
            'comment': self.comment,
            'modified_content': self.modified_content,
            'time_to_apply': self.time_to_apply,
            'effectiveness_score': self.effectiveness_score,
            'created_at': self.created_at.isoformat(),
            'metadata': self.metadata,
        }


@dataclass
class LearningPattern:
    """A learned pattern from historical data."""
    pattern_id: str = field(default_factory=lambda: str(uuid4()))
    type: PatternType = PatternType.VULNERABILITY_PATTERN
    
    # Pattern definition
    name: str = ""
    description: str = ""
    pattern_data: Dict[str, Any] = field(default_factory=dict)
    
    # Statistics
    occurrence_count: int = 0
    success_rate: float = 0.0
    confidence: float = 0.0
    
    # Context
    conditions: Dict[str, Any] = field(default_factory=dict)
    outcomes: List[str] = field(default_factory=list)
    
    # Metadata
    created_at: datetime = field(default_factory=datetime.utcnow)
    last_updated: datetime = field(default_factory=datetime.utcnow)
    last_seen: datetime = field(default_factory=datetime.utcnow)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'pattern_id': self.pattern_id,
            'type': self.type.value,
            'name': self.name,
            'description': self.description,
            'pattern_data': self.pattern_data,
            'occurrence_count': self.occurrence_count,
            'success_rate': self.success_rate,
            'confidence': self.confidence,
            'conditions': self.conditions,
            'outcomes': self.outcomes,
            'created_at': self.created_at.isoformat(),
            'last_updated': self.last_updated.isoformat(),
            'last_seen': self.last_seen.isoformat(),
        }


@dataclass
class KnowledgeNode:
    """A node in the knowledge graph."""
    node_id: str = field(default_factory=lambda: str(uuid4()))
    node_type: str = ""  # vulnerability, fix, technique, control, etc.
    
    # Content
    name: str = ""
    description: str = ""
    properties: Dict[str, Any] = field(default_factory=dict)
    
    # Metadata
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    tags: Set[str] = field(default_factory=set)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'node_id': self.node_id,
            'node_type': self.node_type,
            'name': self.name,
            'description': self.description,
            'properties': self.properties,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat(),
            'tags': list(self.tags),
        }


@dataclass
class KnowledgeEdge:
    """An edge in the knowledge graph."""
    edge_id: str = field(default_factory=lambda: str(uuid4()))
    edge_type: EdgeType = EdgeType.RELATED_TO
    
    # Connection
    source_node_id: str = ""
    target_node_id: str = ""
    
    # Properties
    weight: float = 1.0
    properties: Dict[str, Any] = field(default_factory=dict)
    
    # Metadata
    created_at: datetime = field(default_factory=datetime.utcnow)
    confidence: float = 1.0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'edge_id': self.edge_id,
            'edge_type': self.edge_type.value,
            'source_node_id': self.source_node_id,
            'target_node_id': self.target_node_id,
            'weight': self.weight,
            'properties': self.properties,
            'created_at': self.created_at.isoformat(),
            'confidence': self.confidence,
        }

