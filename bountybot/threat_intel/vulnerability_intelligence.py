"""
Vulnerability Intelligence Engine

Provides vulnerability trending, zero-day detection, and lifecycle tracking.
"""

import secrets
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from pathlib import Path
import json

from .models import VulnerabilityIntelligence, VulnerabilityStatus


class VulnerabilityIntelligenceEngine:
    """Vulnerability intelligence and trending engine."""
    
    def __init__(self, data_dir: str = "./vuln_intel"):
        """
        Initialize vulnerability intelligence engine.
        
        Args:
            data_dir: Directory for vulnerability intelligence data
        """
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(parents=True, exist_ok=True)
        self.vulnerabilities: Dict[str, VulnerabilityIntelligence] = {}
        
        # Load data
        self._load_data()
    
    def track_vulnerability(self, vuln_id: str, **kwargs) -> VulnerabilityIntelligence:
        """
        Track a vulnerability.
        
        Args:
            vuln_id: Vulnerability ID (CVE or internal)
            **kwargs: Vulnerability attributes
            
        Returns:
            VulnerabilityIntelligence object
        """
        if vuln_id in self.vulnerabilities:
            vuln = self.vulnerabilities[vuln_id]
            # Update attributes
            for key, value in kwargs.items():
                if hasattr(vuln, key):
                    setattr(vuln, key, value)
        else:
            vuln = VulnerabilityIntelligence(
                vuln_id=vuln_id,
                last_updated=datetime.utcnow(),
                **kwargs
            )
            self.vulnerabilities[vuln_id] = vuln
        
        vuln.last_updated = datetime.utcnow()
        self._save_vulnerability(vuln)
        
        return vuln
    
    def update_exploitation_status(
        self,
        vuln_id: str,
        exploit_available: bool = False,
        exploit_public: bool = False,
        actively_exploited: bool = False,
        exploit_in_wild: bool = False
    ) -> VulnerabilityIntelligence:
        """
        Update exploitation status for vulnerability.
        
        Args:
            vuln_id: Vulnerability ID
            exploit_available: Whether exploit is available
            exploit_public: Whether exploit is public
            actively_exploited: Whether actively exploited
            exploit_in_wild: Whether exploit seen in wild
            
        Returns:
            Updated VulnerabilityIntelligence
        """
        return self.track_vulnerability(
            vuln_id,
            exploit_available=exploit_available,
            exploit_public=exploit_public,
            actively_exploited=actively_exploited,
            exploit_in_wild=exploit_in_wild
        )
    
    def calculate_trending_score(self, vuln_id: str) -> float:
        """
        Calculate trending score for vulnerability.
        
        Args:
            vuln_id: Vulnerability ID
            
        Returns:
            Trending score (0.0 to 1.0)
        """
        if vuln_id not in self.vulnerabilities:
            return 0.0
        
        vuln = self.vulnerabilities[vuln_id]
        score = 0.0
        
        # Factor 1: Social media mentions (max 0.3)
        if vuln.social_media_mentions > 0:
            score += min(vuln.social_media_mentions / 1000.0, 0.3)
        
        # Factor 2: Dark web mentions (max 0.3)
        if vuln.dark_web_mentions > 0:
            score += min(vuln.dark_web_mentions / 100.0, 0.3)
        
        # Factor 3: Exploit availability (0.2)
        if vuln.exploit_available:
            score += 0.1
        if vuln.exploit_public:
            score += 0.1
        
        # Factor 4: Active exploitation (0.2)
        if vuln.actively_exploited:
            score += 0.1
        if vuln.exploit_in_wild:
            score += 0.1
        
        # Update trending score
        vuln.trending_score = min(score, 1.0)
        self._save_vulnerability(vuln)
        
        return vuln.trending_score
    
    def detect_zero_day(self, vuln_id: str) -> Dict[str, Any]:
        """
        Detect if vulnerability is a zero-day.
        
        Args:
            vuln_id: Vulnerability ID
            
        Returns:
            Zero-day detection result
        """
        if vuln_id not in self.vulnerabilities:
            return {'is_zero_day': False, 'reason': 'Vulnerability not tracked'}
        
        vuln = self.vulnerabilities[vuln_id]
        
        # Zero-day criteria:
        # 1. Exploit available or actively exploited
        # 2. No patch available (status not PATCH_AVAILABLE or PATCH_DEPLOYED)
        
        is_zero_day = (
            (vuln.exploit_available or vuln.actively_exploited) and
            vuln.status not in [VulnerabilityStatus.PATCH_AVAILABLE, VulnerabilityStatus.PATCH_DEPLOYED]
        )
        
        confidence = 0.0
        if is_zero_day:
            confidence = 0.5
            if vuln.actively_exploited:
                confidence += 0.3
            if vuln.exploit_in_wild:
                confidence += 0.2
        
        return {
            'is_zero_day': is_zero_day,
            'confidence': min(confidence, 1.0),
            'exploit_available': vuln.exploit_available,
            'actively_exploited': vuln.actively_exploited,
            'patch_available': vuln.status in [VulnerabilityStatus.PATCH_AVAILABLE, VulnerabilityStatus.PATCH_DEPLOYED],
            'status': vuln.status.value
        }
    
    def get_trending_vulnerabilities(self, limit: int = 10, min_score: float = 0.5) -> List[VulnerabilityIntelligence]:
        """
        Get trending vulnerabilities.
        
        Args:
            limit: Maximum number of results
            min_score: Minimum trending score
            
        Returns:
            List of trending vulnerabilities
        """
        # Calculate trending scores
        for vuln_id in self.vulnerabilities.keys():
            self.calculate_trending_score(vuln_id)
        
        # Filter and sort
        trending = [
            vuln for vuln in self.vulnerabilities.values()
            if vuln.trending_score >= min_score
        ]
        
        trending.sort(key=lambda v: v.trending_score, reverse=True)
        
        return trending[:limit]
    
    def get_actively_exploited(self) -> List[VulnerabilityIntelligence]:
        """
        Get actively exploited vulnerabilities.
        
        Returns:
            List of actively exploited vulnerabilities
        """
        return [
            vuln for vuln in self.vulnerabilities.values()
            if vuln.actively_exploited or vuln.exploit_in_wild
        ]
    
    def get_lifecycle_timeline(self, vuln_id: str) -> Dict[str, Any]:
        """
        Get vulnerability lifecycle timeline.
        
        Args:
            vuln_id: Vulnerability ID
            
        Returns:
            Lifecycle timeline
        """
        if vuln_id not in self.vulnerabilities:
            return {'error': 'Vulnerability not found'}
        
        vuln = self.vulnerabilities[vuln_id]
        
        timeline = []
        
        if vuln.discovery_date:
            timeline.append({
                'event': 'Discovered',
                'date': vuln.discovery_date.isoformat(),
                'days_from_discovery': 0
            })
        
        if vuln.disclosure_date:
            days = (vuln.disclosure_date - vuln.discovery_date).days if vuln.discovery_date else None
            timeline.append({
                'event': 'Disclosed',
                'date': vuln.disclosure_date.isoformat(),
                'days_from_discovery': days
            })
        
        if vuln.first_exploit_date:
            days = (vuln.first_exploit_date - vuln.discovery_date).days if vuln.discovery_date else None
            timeline.append({
                'event': 'First Exploit',
                'date': vuln.first_exploit_date.isoformat(),
                'days_from_discovery': days
            })
        
        if vuln.patch_date:
            days = (vuln.patch_date - vuln.discovery_date).days if vuln.discovery_date else None
            timeline.append({
                'event': 'Patch Released',
                'date': vuln.patch_date.isoformat(),
                'days_from_discovery': days
            })
        
        return {
            'vuln_id': vuln_id,
            'status': vuln.status.value,
            'timeline': timeline,
            'total_days': (datetime.utcnow() - vuln.discovery_date).days if vuln.discovery_date else None
        }
    
    def predict_exploit_likelihood(self, vuln_id: str) -> Dict[str, Any]:
        """
        Predict likelihood of exploitation.
        
        Args:
            vuln_id: Vulnerability ID
            
        Returns:
            Exploit likelihood prediction
        """
        if vuln_id not in self.vulnerabilities:
            return {'likelihood': 0.0, 'confidence': 0.0}
        
        vuln = self.vulnerabilities[vuln_id]
        
        # Factors affecting exploit likelihood
        likelihood = 0.0
        
        # Factor 1: CVSS score (max 0.3)
        if vuln.risk_score >= 9.0:
            likelihood += 0.3
        elif vuln.risk_score >= 7.0:
            likelihood += 0.2
        elif vuln.risk_score >= 4.0:
            likelihood += 0.1
        
        # Factor 2: Exploit availability (0.3)
        if vuln.exploit_available:
            likelihood += 0.15
        if vuln.exploit_public:
            likelihood += 0.15
        
        # Factor 3: Trending (0.2)
        likelihood += vuln.trending_score * 0.2
        
        # Factor 4: Affected systems (0.2)
        if vuln.affected_systems > 10000:
            likelihood += 0.2
        elif vuln.affected_systems > 1000:
            likelihood += 0.15
        elif vuln.affected_systems > 100:
            likelihood += 0.1
        
        likelihood = min(likelihood, 1.0)
        
        return {
            'likelihood': likelihood,
            'confidence': 0.75,
            'factors': {
                'risk_score': vuln.risk_score,
                'exploit_available': vuln.exploit_available,
                'trending_score': vuln.trending_score,
                'affected_systems': vuln.affected_systems
            }
        }
    
    def _load_data(self):
        """Load vulnerability intelligence data."""
        data_file = self.data_dir / "vulnerabilities.json"
        
        if data_file.exists():
            try:
                with open(data_file, 'r') as f:
                    data = json.load(f)
                    
                for vuln_id, vuln_dict in data.items():
                    # Convert datetime strings
                    for date_field in ['discovery_date', 'disclosure_date', 'patch_date', 'first_exploit_date', 'last_updated']:
                        if vuln_dict.get(date_field):
                            vuln_dict[date_field] = datetime.fromisoformat(vuln_dict[date_field])
                    
                    # Convert enum
                    vuln_dict['status'] = VulnerabilityStatus(vuln_dict['status'])
                    
                    self.vulnerabilities[vuln_id] = VulnerabilityIntelligence(**vuln_dict)
            except Exception:
                pass
    
    def _save_vulnerability(self, vuln: VulnerabilityIntelligence):
        """Save vulnerability intelligence data."""
        data_file = self.data_dir / "vulnerabilities.json"
        
        # Load existing data
        data = {}
        if data_file.exists():
            try:
                with open(data_file, 'r') as f:
                    data = json.load(f)
            except Exception:
                pass
        
        # Add/update vulnerability
        vuln_dict = {
            'vuln_id': vuln.vuln_id,
            'status': vuln.status.value,
            'exploit_available': vuln.exploit_available,
            'exploit_public': vuln.exploit_public,
            'actively_exploited': vuln.actively_exploited,
            'exploit_in_wild': vuln.exploit_in_wild,
            'trending_score': vuln.trending_score,
            'social_media_mentions': vuln.social_media_mentions,
            'dark_web_mentions': vuln.dark_web_mentions,
            'discovery_date': vuln.discovery_date.isoformat() if vuln.discovery_date else None,
            'disclosure_date': vuln.disclosure_date.isoformat() if vuln.disclosure_date else None,
            'patch_date': vuln.patch_date.isoformat() if vuln.patch_date else None,
            'first_exploit_date': vuln.first_exploit_date.isoformat() if vuln.first_exploit_date else None,
            'risk_score': vuln.risk_score,
            'exploitability_score': vuln.exploitability_score,
            'impact_score': vuln.impact_score,
            'affected_systems': vuln.affected_systems,
            'related_cves': vuln.related_cves,
            'mitre_techniques': vuln.mitre_techniques,
            'last_updated': vuln.last_updated.isoformat() if vuln.last_updated else None,
            'sources': vuln.sources
        }
        
        data[vuln.vuln_id] = vuln_dict
        
        # Save to disk
        try:
            with open(data_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception:
            pass

