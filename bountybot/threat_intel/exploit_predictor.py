"""
Exploit Prediction System

ML-based system to predict exploit likelihood, weaponization timeline,
and exploitation probability for vulnerabilities.
"""

import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum

from .models import CVEData, ExploitData, ExploitMaturity


class ExploitLikelihood(Enum):
    """Likelihood of exploit development."""
    VERY_LOW = "very_low"
    LOW = "low"
    MODERATE = "moderate"
    HIGH = "high"
    VERY_HIGH = "very_high"
    IMMINENT = "imminent"


@dataclass
class ExploitPrediction:
    """Prediction of exploit development and weaponization."""
    
    # Vulnerability info
    vulnerability_id: str
    vulnerability_type: str
    
    # Exploit likelihood
    exploit_likelihood: ExploitLikelihood = ExploitLikelihood.LOW
    exploit_probability: float = 0.0
    
    # Weaponization timeline
    predicted_weaponization_days: Optional[int] = None
    weaponization_confidence: float = 0.0
    
    # Exploitation timeline
    predicted_exploitation_days: Optional[int] = None
    exploitation_confidence: float = 0.0
    
    # Risk factors
    risk_factors: List[str] = field(default_factory=list)
    protective_factors: List[str] = field(default_factory=list)
    
    # Feature scores
    technical_complexity_score: float = 0.0
    exploit_value_score: float = 0.0
    attacker_interest_score: float = 0.0
    defense_difficulty_score: float = 0.0
    
    # Recommendations
    priority_level: str = "low"
    recommended_timeline: str = "standard"
    mitigation_urgency: str = "routine"
    
    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            'vulnerability_id': self.vulnerability_id,
            'vulnerability_type': self.vulnerability_type,
            'exploit_likelihood': self.exploit_likelihood.value,
            'exploit_probability': self.exploit_probability,
            'predicted_weaponization_days': self.predicted_weaponization_days,
            'weaponization_confidence': self.weaponization_confidence,
            'predicted_exploitation_days': self.predicted_exploitation_days,
            'exploitation_confidence': self.exploitation_confidence,
            'risk_factors': self.risk_factors,
            'protective_factors': self.protective_factors,
            'technical_complexity_score': self.technical_complexity_score,
            'exploit_value_score': self.exploit_value_score,
            'attacker_interest_score': self.attacker_interest_score,
            'defense_difficulty_score': self.defense_difficulty_score,
            'priority_level': self.priority_level,
            'recommended_timeline': self.recommended_timeline,
            'mitigation_urgency': self.mitigation_urgency
        }


class ExploitPredictor:
    """
    ML-based exploit prediction system.
    
    Predicts exploit likelihood and weaponization timeline based on
    vulnerability characteristics, historical patterns, and threat intelligence.
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """Initialize exploit predictor."""
        self.config = config or {}
        
        # Historical data for ML model
        self.historical_exploits: List[Dict] = []
        
        # Vulnerability type exploit rates (from historical data)
        self.exploit_rates = {
            'SQL Injection': 0.85,
            'Remote Code Execution': 0.92,
            'Command Injection': 0.88,
            'Cross-Site Scripting': 0.65,
            'Path Traversal': 0.70,
            'SSRF': 0.75,
            'XXE': 0.68,
            'SSTI': 0.80,
            'Deserialization': 0.90,
            'Authentication Bypass': 0.82,
            'Authorization Bypass': 0.78,
            'Information Disclosure': 0.45,
            'CSRF': 0.40,
            'Open Redirect': 0.30,
            'JWT Vulnerability': 0.72
        }
        
        # Average weaponization timelines (days)
        self.weaponization_timelines = {
            'Remote Code Execution': 7,
            'SQL Injection': 14,
            'Command Injection': 10,
            'Deserialization': 12,
            'Authentication Bypass': 15,
            'SSRF': 20,
            'XXE': 25,
            'SSTI': 18,
            'Path Traversal': 21,
            'Cross-Site Scripting': 30,
            'XSS': 30,
            'Authorization Bypass': 18,
            'JWT Vulnerability': 16,
            'Information Disclosure': 45,
            'CSRF': 40,
            'Open Redirect': 50,
            'RCE': 7
        }
        
        # Statistics
        self.total_predictions = 0
    
    async def predict(
        self,
        vulnerability_id: str,
        vulnerability_type: str,
        cvss_score: Optional[float] = None,
        cve_data: Optional[CVEData] = None,
        exploit_data: Optional[List[ExploitData]] = None,
        public_disclosure: bool = False,
        proof_of_concept_available: bool = False,
        vendor_patch_available: bool = False,
        affected_products: Optional[List[str]] = None,
        attack_vector: Optional[str] = None,
        privileges_required: Optional[str] = None,
        user_interaction: Optional[str] = None
    ) -> ExploitPrediction:
        """
        Predict exploit likelihood and timeline.
        
        Args:
            vulnerability_id: Unique vulnerability identifier
            vulnerability_type: Type of vulnerability
            cvss_score: CVSS score (0-10)
            cve_data: CVE data if available
            exploit_data: Existing exploit data
            public_disclosure: Whether vulnerability is publicly disclosed
            proof_of_concept_available: Whether PoC is available
            vendor_patch_available: Whether vendor patch is available
            affected_products: List of affected products
            attack_vector: CVSS attack vector (Network, Adjacent, Local, Physical)
            privileges_required: CVSS privileges required (None, Low, High)
            user_interaction: CVSS user interaction (None, Required)
        
        Returns:
            ExploitPrediction with likelihood and timeline
        """
        self.total_predictions += 1
        
        prediction = ExploitPrediction(
            vulnerability_id=vulnerability_id,
            vulnerability_type=vulnerability_type
        )
        
        # Calculate feature scores
        prediction.technical_complexity_score = self._calculate_technical_complexity(
            vulnerability_type, attack_vector, privileges_required, user_interaction
        )
        
        prediction.exploit_value_score = self._calculate_exploit_value(
            vulnerability_type, cvss_score, affected_products
        )
        
        prediction.attacker_interest_score = self._calculate_attacker_interest(
            vulnerability_type, public_disclosure, proof_of_concept_available,
            exploit_data
        )
        
        prediction.defense_difficulty_score = self._calculate_defense_difficulty(
            vulnerability_type, vendor_patch_available, attack_vector
        )
        
        # Calculate exploit probability
        prediction.exploit_probability = self._calculate_exploit_probability(
            prediction.technical_complexity_score,
            prediction.exploit_value_score,
            prediction.attacker_interest_score,
            prediction.defense_difficulty_score
        )
        
        # Determine exploit likelihood
        prediction.exploit_likelihood = self._determine_exploit_likelihood(
            prediction.exploit_probability
        )
        
        # Predict weaponization timeline
        prediction.predicted_weaponization_days, prediction.weaponization_confidence = \
            self._predict_weaponization_timeline(
                vulnerability_type,
                prediction.technical_complexity_score,
                proof_of_concept_available,
                exploit_data
            )
        
        # Predict exploitation timeline
        prediction.predicted_exploitation_days, prediction.exploitation_confidence = \
            self._predict_exploitation_timeline(
                prediction.predicted_weaponization_days,
                public_disclosure,
                vendor_patch_available
            )
        
        # Identify risk and protective factors
        self._identify_risk_factors(prediction, locals())
        self._identify_protective_factors(prediction, locals())
        
        # Generate recommendations
        self._generate_recommendations(prediction)
        
        return prediction
    
    def _calculate_technical_complexity(
        self,
        vulnerability_type: str,
        attack_vector: Optional[str],
        privileges_required: Optional[str],
        user_interaction: Optional[str]
    ) -> float:
        """Calculate technical complexity score (0-1, lower = easier to exploit)."""
        score = 0.5  # Base score
        
        # Vulnerability type complexity
        easy_types = ['SQL Injection', 'Command Injection', 'Path Traversal']
        moderate_types = ['XSS', 'SSRF', 'XXE', 'Open Redirect']
        hard_types = ['Deserialization', 'Race Condition', 'Memory Corruption']
        
        if any(t in vulnerability_type for t in easy_types):
            score -= 0.2
        elif any(t in vulnerability_type for t in hard_types):
            score += 0.2
        
        # Attack vector
        if attack_vector == 'Network':
            score -= 0.15
        elif attack_vector == 'Adjacent':
            score += 0.05
        elif attack_vector in ['Local', 'Physical']:
            score += 0.15
        
        # Privileges required
        if privileges_required == 'None':
            score -= 0.1
        elif privileges_required == 'High':
            score += 0.1
        
        # User interaction
        if user_interaction == 'None':
            score -= 0.05
        elif user_interaction == 'Required':
            score += 0.05
        
        return max(0.0, min(1.0, score))
    
    def _calculate_exploit_value(
        self,
        vulnerability_type: str,
        cvss_score: Optional[float],
        affected_products: Optional[List[str]]
    ) -> float:
        """Calculate exploit value score (0-1, higher = more valuable)."""
        score = 0.5  # Base score
        
        # CVSS score
        if cvss_score:
            score += (cvss_score / 10.0) * 0.3
        
        # Vulnerability type value
        high_value_types = ['Remote Code Execution', 'Authentication Bypass', 'Deserialization']
        moderate_value_types = ['SQL Injection', 'Command Injection', 'SSRF']
        
        if any(t in vulnerability_type for t in high_value_types):
            score += 0.2
        elif any(t in vulnerability_type for t in moderate_value_types):
            score += 0.1
        
        # Affected products (more = higher value)
        if affected_products:
            product_score = min(len(affected_products) * 0.05, 0.2)
            score += product_score
        
        return max(0.0, min(1.0, score))
    
    def _calculate_attacker_interest(
        self,
        vulnerability_type: str,
        public_disclosure: bool,
        proof_of_concept_available: bool,
        exploit_data: Optional[List[ExploitData]]
    ) -> float:
        """Calculate attacker interest score (0-1, higher = more interest)."""
        score = 0.3  # Base score
        
        # Public disclosure
        if public_disclosure:
            score += 0.2
        
        # PoC available
        if proof_of_concept_available:
            score += 0.25
        
        # Existing exploits
        if exploit_data:
            score += min(len(exploit_data) * 0.1, 0.3)
        
        # Vulnerability type interest
        base_rate = self.exploit_rates.get(vulnerability_type, 0.5)
        score += (base_rate - 0.5) * 0.3

        return max(0.0, min(1.0, score))

    def _calculate_defense_difficulty(
        self,
        vulnerability_type: str,
        vendor_patch_available: bool,
        attack_vector: Optional[str]
    ) -> float:
        """Calculate defense difficulty score (0-1, higher = harder to defend)."""
        score = 0.5  # Base score

        # Vendor patch
        if vendor_patch_available:
            score -= 0.3
        else:
            score += 0.2

        # Attack vector
        if attack_vector == 'Network':
            score += 0.15  # Harder to defend against network attacks
        elif attack_vector in ['Local', 'Physical']:
            score -= 0.15  # Easier to defend against local attacks

        # Vulnerability type
        hard_to_defend = ['Zero-Day', 'Logic Flaw', 'Design Flaw']
        if any(t in vulnerability_type for t in hard_to_defend):
            score += 0.15

        return max(0.0, min(1.0, score))

    def _calculate_exploit_probability(
        self,
        technical_complexity: float,
        exploit_value: float,
        attacker_interest: float,
        defense_difficulty: float
    ) -> float:
        """Calculate overall exploit probability."""
        # Weighted combination
        probability = (
            (1.0 - technical_complexity) * 0.25 +  # Lower complexity = higher probability
            exploit_value * 0.30 +
            attacker_interest * 0.30 +
            defense_difficulty * 0.15
        )

        return max(0.0, min(1.0, probability))

    def _determine_exploit_likelihood(self, probability: float) -> ExploitLikelihood:
        """Determine exploit likelihood category."""
        if probability >= 0.9:
            return ExploitLikelihood.IMMINENT
        elif probability >= 0.75:
            return ExploitLikelihood.VERY_HIGH
        elif probability >= 0.6:
            return ExploitLikelihood.HIGH
        elif probability >= 0.4:
            return ExploitLikelihood.MODERATE
        elif probability >= 0.2:
            return ExploitLikelihood.LOW
        else:
            return ExploitLikelihood.VERY_LOW

    def _predict_weaponization_timeline(
        self,
        vulnerability_type: str,
        technical_complexity: float,
        proof_of_concept_available: bool,
        exploit_data: Optional[List[ExploitData]]
    ) -> Tuple[Optional[int], float]:
        """Predict weaponization timeline in days."""
        # Check if already weaponized (HIGH maturity)
        if exploit_data:
            for exploit in exploit_data:
                if exploit.maturity == ExploitMaturity.HIGH:
                    return 0, 1.0  # Already weaponized

        # Base timeline from historical data
        base_days = self.weaponization_timelines.get(vulnerability_type, 30)

        # Adjust for technical complexity
        complexity_multiplier = 0.5 + (technical_complexity * 1.5)
        adjusted_days = int(base_days * complexity_multiplier)

        # Adjust for PoC availability
        if proof_of_concept_available:
            adjusted_days = int(adjusted_days * 0.6)  # 40% faster with PoC

        # Adjust for existing exploits
        if exploit_data:
            maturity_reduction = {
                ExploitMaturity.PROOF_OF_CONCEPT: 0.7,
                ExploitMaturity.FUNCTIONAL: 0.5,
                ExploitMaturity.HIGH: 0.3
            }

            max_maturity = max([e.maturity for e in exploit_data],
                             key=lambda m: list(maturity_reduction.keys()).index(m)
                             if m in maturity_reduction else -1)

            if max_maturity in maturity_reduction:
                adjusted_days = int(adjusted_days * maturity_reduction[max_maturity])

        # Calculate confidence
        confidence = 0.6  # Base confidence
        if proof_of_concept_available:
            confidence += 0.2
        if exploit_data:
            confidence += 0.2

        confidence = min(confidence, 0.95)

        return adjusted_days, confidence

    def _predict_exploitation_timeline(
        self,
        weaponization_days: Optional[int],
        public_disclosure: bool,
        vendor_patch_available: bool
    ) -> Tuple[Optional[int], float]:
        """Predict exploitation timeline in days."""
        if weaponization_days is None:
            return None, 0.0

        # Base exploitation delay after weaponization
        base_delay = 7  # Days

        # Adjust for public disclosure
        if public_disclosure:
            base_delay = int(base_delay * 0.5)  # Faster exploitation

        # Adjust for patch availability
        if vendor_patch_available:
            base_delay = int(base_delay * 1.5)  # Slower exploitation (some patch)
        else:
            base_delay = int(base_delay * 0.7)  # Faster exploitation (no patch)

        total_days = weaponization_days + base_delay

        # Calculate confidence
        confidence = 0.5  # Base confidence
        if public_disclosure:
            confidence += 0.15
        if vendor_patch_available:
            confidence += 0.1

        confidence = min(confidence, 0.85)

        return total_days, confidence

    def _identify_risk_factors(self, prediction: ExploitPrediction, context: Dict):
        """Identify risk factors that increase exploit likelihood."""
        risk_factors = []

        if context.get('public_disclosure'):
            risk_factors.append("Publicly disclosed vulnerability")

        if context.get('proof_of_concept_available'):
            risk_factors.append("Proof-of-concept exploit available")

        if context.get('exploit_data'):
            risk_factors.append(f"{len(context['exploit_data'])} existing exploit(s)")

        if not context.get('vendor_patch_available'):
            risk_factors.append("No vendor patch available")

        if context.get('attack_vector') == 'Network':
            risk_factors.append("Network-accessible vulnerability")

        if context.get('privileges_required') == 'None':
            risk_factors.append("No privileges required")

        if context.get('user_interaction') == 'None':
            risk_factors.append("No user interaction required")

        cvss_score = context.get('cvss_score')
        if cvss_score is not None:
            if cvss_score >= 9.0:
                risk_factors.append("Critical CVSS score (≥9.0)")
            elif cvss_score >= 7.0:
                risk_factors.append("High CVSS score (≥7.0)")

        if prediction.technical_complexity_score < 0.3:
            risk_factors.append("Low technical complexity")

        if prediction.exploit_value_score > 0.7:
            risk_factors.append("High exploit value")

        prediction.risk_factors = risk_factors

    def _identify_protective_factors(self, prediction: ExploitPrediction, context: Dict):
        """Identify protective factors that decrease exploit likelihood."""
        protective_factors = []

        if context.get('vendor_patch_available'):
            protective_factors.append("Vendor patch available")

        if not context.get('public_disclosure'):
            protective_factors.append("Not publicly disclosed")

        if context.get('attack_vector') in ['Local', 'Physical']:
            protective_factors.append("Local/physical access required")

        if context.get('privileges_required') == 'High':
            protective_factors.append("High privileges required")

        if context.get('user_interaction') == 'Required':
            protective_factors.append("User interaction required")

        if prediction.technical_complexity_score > 0.7:
            protective_factors.append("High technical complexity")

        if not context.get('proof_of_concept_available'):
            protective_factors.append("No public PoC available")

        prediction.protective_factors = protective_factors

    def _generate_recommendations(self, prediction: ExploitPrediction):
        """Generate recommendations based on prediction."""
        # Priority level
        if prediction.exploit_probability >= 0.8:
            prediction.priority_level = "critical"
            prediction.recommended_timeline = "immediate (24 hours)"
            prediction.mitigation_urgency = "emergency"
        elif prediction.exploit_probability >= 0.6:
            prediction.priority_level = "high"
            prediction.recommended_timeline = "urgent (7 days)"
            prediction.mitigation_urgency = "high"
        elif prediction.exploit_probability >= 0.4:
            prediction.priority_level = "medium"
            prediction.recommended_timeline = "standard (30 days)"
            prediction.mitigation_urgency = "moderate"
        else:
            prediction.priority_level = "low"
            prediction.recommended_timeline = "routine (90 days)"
            prediction.mitigation_urgency = "routine"

    def get_statistics(self) -> Dict:
        """Get predictor statistics."""
        return {
            'total_predictions': self.total_predictions,
            'historical_exploits': len(self.historical_exploits)
        }

    async def batch_predict(
        self,
        vulnerabilities: List[Dict]
    ) -> List[ExploitPrediction]:
        """
        Predict exploit likelihood for multiple vulnerabilities.

        Args:
            vulnerabilities: List of vulnerability data dictionaries

        Returns:
            List of ExploitPrediction objects
        """
        predictions = []
        for vuln in vulnerabilities:
            prediction = await self.predict(**vuln)
            predictions.append(prediction)

        return predictions
