import logging
import re
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from enum import Enum

logger = logging.getLogger(__name__)


class SkillLevel(Enum):
    """Required attacker skill level."""
    SCRIPT_KIDDIE = "script_kiddie"  # Can use existing tools
    NOVICE = "novice"  # Basic understanding required
    INTERMEDIATE = "intermediate"  # Solid technical knowledge
    ADVANCED = "advanced"  # Deep expertise required
    EXPERT = "expert"  # Cutting-edge research level


class TimeToExploit(Enum):
    """Estimated time to develop working exploit."""
    MINUTES = "minutes"  # < 30 minutes
    HOURS = "hours"  # 1-8 hours
    DAYS = "days"  # 1-7 days
    WEEKS = "weeks"  # 1-4 weeks
    MONTHS = "months"  # > 1 month


@dataclass
class ComplexityFactor:
    """Individual complexity factor."""
    name: str
    score: float  # 0-100, higher = easier
    weight: float  # Importance weight
    description: str
    details: Optional[str] = None


@dataclass
class ExploitComplexityScore:
    """Complete exploit complexity analysis."""
    overall_score: float  # 0-100, higher = easier to exploit
    skill_level: SkillLevel
    time_to_exploit: TimeToExploit
    factors: List[ComplexityFactor] = field(default_factory=list)
    prerequisites: List[str] = field(default_factory=list)
    barriers: List[str] = field(default_factory=list)
    automation_potential: float = 0.0  # 0-100, can it be automated?
    reliability: float = 0.0  # 0-100, how reliable is exploitation?
    reasoning: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'overall_score': self.overall_score,
            'skill_level': self.skill_level.value,
            'time_to_exploit': self.time_to_exploit.value,
            'factors': [
                {
                    'name': f.name,
                    'score': f.score,
                    'weight': f.weight,
                    'description': f.description,
                    'details': f.details,
                }
                for f in self.factors
            ],
            'prerequisites': self.prerequisites,
            'barriers': self.barriers,
            'automation_potential': self.automation_potential,
            'reliability': self.reliability,
            'reasoning': self.reasoning,
        }


class ExploitComplexityAnalyzer:
    """
    Analyzes exploit complexity using multiple factors:
    
    1. Authentication Requirements (30%)
    2. User Interaction (20%)
    3. Attack Steps (15%)
    4. Timing/Race Conditions (10%)
    5. Privilege Level (10%)
    6. Network Position (10%)
    7. Special Conditions (5%)
    """
    
    # Complexity indicators
    HIGH_COMPLEXITY_INDICATORS = [
        'race condition', 'timing attack', 'blind', 'time-based',
        'requires multiple requests', 'brute force', 'requires guessing',
        'requires social engineering', 'physical access', 'local access',
        'requires admin', 'requires root', 'kernel', 'requires reboot',
    ]
    
    LOW_COMPLEXITY_INDICATORS = [
        'unauthenticated', 'no authentication', 'anonymous',
        'single request', 'one-click', 'direct access',
        'publicly accessible', 'no interaction', 'automated',
        'remote', 'network accessible', 'internet facing',
    ]
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize exploit complexity analyzer.
        
        Args:
            config: Optional configuration dictionary
        """
        self.config = config or {}
        logger.info("Initialized ExploitComplexityAnalyzer")
    
    def analyze(self, report, validation_result=None, cvss_score=None) -> ExploitComplexityScore:
        """
        Analyze exploit complexity for a vulnerability.
        
        Args:
            report: Bug bounty report
            validation_result: Optional validation result
            cvss_score: Optional CVSS score for additional context
            
        Returns:
            Exploit complexity score with detailed analysis
        """
        logger.debug(f"Analyzing exploit complexity: {report.title}")
        
        factors = []
        prerequisites = []
        barriers = []
        
        # 1. Authentication Requirements (30% weight)
        auth_score, auth_prereqs, auth_barriers = self._analyze_authentication(report, cvss_score)
        factors.append(ComplexityFactor(
            name="authentication",
            score=auth_score,
            weight=0.30,
            description="Authentication requirements",
            details=f"Prerequisites: {len(auth_prereqs)}, Barriers: {len(auth_barriers)}"
        ))
        prerequisites.extend(auth_prereqs)
        barriers.extend(auth_barriers)
        
        # 2. User Interaction (20% weight)
        interaction_score, interaction_details = self._analyze_user_interaction(report, cvss_score)
        factors.append(ComplexityFactor(
            name="user_interaction",
            score=interaction_score,
            weight=0.20,
            description="User interaction requirements",
            details=interaction_details
        ))
        
        # 3. Attack Steps (15% weight)
        steps_score, steps_details = self._analyze_attack_steps(report)
        factors.append(ComplexityFactor(
            name="attack_steps",
            score=steps_score,
            weight=0.15,
            description="Number and complexity of attack steps",
            details=steps_details
        ))
        
        # 4. Timing/Race Conditions (10% weight)
        timing_score, timing_barriers = self._analyze_timing_requirements(report)
        factors.append(ComplexityFactor(
            name="timing",
            score=timing_score,
            weight=0.10,
            description="Timing and race condition requirements",
            details=f"Barriers: {len(timing_barriers)}"
        ))
        barriers.extend(timing_barriers)
        
        # 5. Privilege Level (10% weight)
        privilege_score, privilege_prereqs = self._analyze_privilege_requirements(report, cvss_score)
        factors.append(ComplexityFactor(
            name="privileges",
            score=privilege_score,
            weight=0.10,
            description="Required privilege level",
            details=f"Prerequisites: {len(privilege_prereqs)}"
        ))
        prerequisites.extend(privilege_prereqs)
        
        # 6. Network Position (10% weight)
        network_score, network_details = self._analyze_network_position(report, cvss_score)
        factors.append(ComplexityFactor(
            name="network_position",
            score=network_score,
            weight=0.10,
            description="Required network position",
            details=network_details
        ))
        
        # 7. Special Conditions (5% weight)
        special_score, special_barriers = self._analyze_special_conditions(report)
        factors.append(ComplexityFactor(
            name="special_conditions",
            score=special_score,
            weight=0.05,
            description="Special conditions or constraints",
            details=f"Barriers: {len(special_barriers)}"
        ))
        barriers.extend(special_barriers)
        
        # Calculate overall score (weighted average)
        overall_score = sum(f.score * f.weight for f in factors)
        
        # Determine skill level
        skill_level = self._determine_skill_level(overall_score, factors)
        
        # Estimate time to exploit
        time_to_exploit = self._estimate_time_to_exploit(overall_score, len(prerequisites), len(barriers))
        
        # Calculate automation potential
        automation_potential = self._calculate_automation_potential(factors, report)
        
        # Calculate reliability
        reliability = self._calculate_reliability(factors, report)
        
        # Generate reasoning
        reasoning = self._generate_reasoning(overall_score, skill_level, time_to_exploit, factors)
        
        result = ExploitComplexityScore(
            overall_score=round(overall_score, 2),
            skill_level=skill_level,
            time_to_exploit=time_to_exploit,
            factors=factors,
            prerequisites=prerequisites,
            barriers=barriers,
            automation_potential=round(automation_potential, 2),
            reliability=round(reliability, 2),
            reasoning=reasoning,
        )
        
        logger.info(f"Exploit Complexity: score={overall_score:.1f}, skill={skill_level.value}, time={time_to_exploit.value}")
        return result
    
    def _analyze_authentication(self, report, cvss_score) -> tuple:
        """Analyze authentication requirements."""
        score = 50.0  # Default: moderate
        prerequisites = []
        barriers = []
        
        report_text = f"{report.title} {report.impact_description or ''}".lower()
        steps_text = " ".join(report.reproduction_steps).lower() if report.reproduction_steps else ""
        
        # Check CVSS first if available
        if cvss_score and hasattr(cvss_score, 'privileges_required'):
            pr_value = cvss_score.privileges_required[0]  # Get the code (N/L/H)
            if pr_value == 'N':
                score = 90.0  # No auth required = easy
            elif pr_value == 'L':
                score = 60.0  # Low privileges = moderate
                prerequisites.append("Low-privilege account required")
            elif pr_value == 'H':
                score = 30.0  # High privileges = hard
                prerequisites.append("High-privilege account required")
                barriers.append("Requires elevated privileges")
        else:
            # Analyze from report text
            if any(word in report_text or word in steps_text for word in ['unauthenticated', 'no authentication', 'anonymous', 'without login']):
                score = 90.0
            elif any(word in report_text or word in steps_text for word in ['authenticated', 'logged in', 'after login', 'requires login']):
                score = 60.0
                prerequisites.append("Valid user account required")
            elif any(word in report_text or word in steps_text for word in ['admin', 'administrator', 'root', 'privileged']):
                score = 30.0
                prerequisites.append("Administrative access required")
                barriers.append("Requires admin privileges")
        
        return score, prerequisites, barriers

    def _analyze_user_interaction(self, report, cvss_score) -> tuple:
        """Analyze user interaction requirements."""
        score = 50.0
        details = "Moderate interaction"

        report_text = f"{report.title} {report.impact_description or ''}".lower()

        # Check CVSS first
        if cvss_score and hasattr(cvss_score, 'user_interaction'):
            ui_value = cvss_score.user_interaction[0]
            if ui_value == 'N':
                score = 90.0
                details = "No user interaction required"
            elif ui_value == 'R':
                score = 50.0
                details = "User interaction required"
        else:
            # Analyze from report
            if any(word in report_text for word in ['no interaction', 'no user', 'automated', 'direct']):
                score = 90.0
                details = "No user interaction required"
            elif any(word in report_text for word in ['click', 'visit', 'open', 'user must', 'victim must']):
                score = 50.0
                details = "User interaction required"
            elif any(word in report_text for word in ['social engineering', 'convince', 'trick']):
                score = 20.0
                details = "Significant social engineering required"

        return score, details

    def _analyze_attack_steps(self, report) -> tuple:
        """Analyze number and complexity of attack steps."""
        score = 50.0

        if not report.reproduction_steps:
            details = "No reproduction steps provided"
            return score, details

        num_steps = len(report.reproduction_steps)
        steps_text = " ".join(report.reproduction_steps).lower()

        # Score based on number of steps
        if num_steps <= 2:
            score = 90.0
            details = f"Simple attack ({num_steps} steps)"
        elif num_steps <= 5:
            score = 70.0
            details = f"Moderate complexity ({num_steps} steps)"
        elif num_steps <= 10:
            score = 40.0
            details = f"Complex attack ({num_steps} steps)"
        else:
            score = 20.0
            details = f"Very complex attack ({num_steps} steps)"

        # Adjust for complexity indicators
        if any(indicator in steps_text for indicator in self.HIGH_COMPLEXITY_INDICATORS):
            score -= 20
            details += ", high complexity indicators found"

        if any(indicator in steps_text for indicator in self.LOW_COMPLEXITY_INDICATORS):
            score += 10
            details += ", low complexity indicators found"

        return max(0, min(100, score)), details

    def _analyze_timing_requirements(self, report) -> tuple:
        """Analyze timing and race condition requirements."""
        score = 90.0  # Default: no timing requirements
        barriers = []

        report_text = f"{report.title} {report.impact_description or ''}".lower()
        steps_text = " ".join(report.reproduction_steps).lower() if report.reproduction_steps else ""

        timing_keywords = ['race condition', 'timing', 'time-based', 'toctou', 'time of check']

        if any(keyword in report_text or keyword in steps_text for keyword in timing_keywords):
            score = 30.0
            barriers.append("Requires precise timing or race condition exploitation")

        if 'blind' in report_text or 'time-based' in report_text:
            score = min(score, 40.0)
            barriers.append("Blind exploitation requires timing analysis")

        return score, barriers

    def _analyze_privilege_requirements(self, report, cvss_score) -> tuple:
        """Analyze required privilege level."""
        score = 50.0
        prerequisites = []

        # Already handled in authentication analysis, but check for escalation
        report_text = f"{report.title} {report.impact_description or ''}".lower()

        if 'privilege escalation' in report_text or 'escalate' in report_text:
            score = 70.0  # Escalation is valuable even if requires initial access
            prerequisites.append("Initial low-privilege access")
        elif 'no privileges' in report_text or 'unprivileged' in report_text:
            score = 90.0

        return score, prerequisites

    def _analyze_network_position(self, report, cvss_score) -> tuple:
        """Analyze required network position."""
        score = 50.0
        details = "Moderate network access"

        report_text = f"{report.title} {report.impact_description or ''}".lower()

        # Check CVSS first
        if cvss_score and hasattr(cvss_score, 'attack_vector'):
            av_value = cvss_score.attack_vector[0]
            if av_value == 'N':
                score = 90.0
                details = "Network/Internet accessible"
            elif av_value == 'A':
                score = 60.0
                details = "Adjacent network required"
            elif av_value == 'L':
                score = 30.0
                details = "Local access required"
            elif av_value == 'P':
                score = 10.0
                details = "Physical access required"
        else:
            # Analyze from report
            if any(word in report_text for word in ['remote', 'internet', 'network', 'publicly accessible']):
                score = 90.0
                details = "Remote/Internet accessible"
            elif any(word in report_text for word in ['local', 'localhost', 'same machine']):
                score = 30.0
                details = "Local access required"
            elif any(word in report_text for word in ['physical', 'physical access']):
                score = 10.0
                details = "Physical access required"

        return score, details

    def _analyze_special_conditions(self, report) -> tuple:
        """Analyze special conditions or constraints."""
        score = 90.0  # Default: no special conditions
        barriers = []

        report_text = f"{report.title} {report.impact_description or ''}".lower()
        steps_text = " ".join(report.reproduction_steps).lower() if report.reproduction_steps else ""

        special_conditions = {
            'specific browser': 20,
            'specific version': 15,
            'specific configuration': 20,
            'requires reboot': 30,
            'requires restart': 25,
            'specific os': 15,
            'specific platform': 15,
        }

        for condition, penalty in special_conditions.items():
            if condition in report_text or condition in steps_text:
                score -= penalty
                barriers.append(f"Requires {condition}")

        return max(0, score), barriers

    def _determine_skill_level(self, overall_score: float, factors: List[ComplexityFactor]) -> SkillLevel:
        """Determine required attacker skill level."""
        if overall_score >= 80:
            return SkillLevel.SCRIPT_KIDDIE
        elif overall_score >= 60:
            return SkillLevel.NOVICE
        elif overall_score >= 40:
            return SkillLevel.INTERMEDIATE
        elif overall_score >= 20:
            return SkillLevel.ADVANCED
        else:
            return SkillLevel.EXPERT

    def _estimate_time_to_exploit(self, overall_score: float, num_prerequisites: int, num_barriers: int) -> TimeToExploit:
        """Estimate time to develop working exploit."""
        # Base estimate on score
        if overall_score >= 80 and num_prerequisites <= 1 and num_barriers == 0:
            return TimeToExploit.MINUTES
        elif overall_score >= 60 and num_prerequisites <= 2 and num_barriers <= 1:
            return TimeToExploit.HOURS
        elif overall_score >= 40 and num_prerequisites <= 4 and num_barriers <= 3:
            return TimeToExploit.DAYS
        elif overall_score >= 20:
            return TimeToExploit.WEEKS
        else:
            return TimeToExploit.MONTHS

    def _calculate_automation_potential(self, factors: List[ComplexityFactor], report) -> float:
        """Calculate how easily the exploit can be automated."""
        score = 100.0

        # Check user interaction factor
        ui_factor = next((f for f in factors if f.name == "user_interaction"), None)
        if ui_factor and ui_factor.score < 70:
            score -= 40  # User interaction reduces automation

        # Check timing factor
        timing_factor = next((f for f in factors if f.name == "timing"), None)
        if timing_factor and timing_factor.score < 70:
            score -= 30  # Timing requirements reduce automation

        # Check steps complexity
        steps_factor = next((f for f in factors if f.name == "attack_steps"), None)
        if steps_factor and steps_factor.score < 50:
            score -= 20  # Complex steps reduce automation

        return max(0, score)

    def _calculate_reliability(self, factors: List[ComplexityFactor], report) -> float:
        """Calculate exploit reliability."""
        score = 100.0

        # Timing issues reduce reliability
        timing_factor = next((f for f in factors if f.name == "timing"), None)
        if timing_factor and timing_factor.score < 70:
            score -= 40

        # Special conditions reduce reliability
        special_factor = next((f for f in factors if f.name == "special_conditions"), None)
        if special_factor and special_factor.score < 70:
            score -= 20

        # Check for reliability keywords in report
        report_text = f"{report.title} {report.impact_description or ''}".lower()
        if any(word in report_text for word in ['unreliable', 'sometimes', 'occasionally', 'intermittent']):
            score -= 30

        return max(0, score)

    def _generate_reasoning(self, overall_score: float, skill_level: SkillLevel,
                           time_to_exploit: TimeToExploit, factors: List[ComplexityFactor]) -> str:
        """Generate human-readable reasoning."""
        difficulty = "very easy" if overall_score >= 80 else \
                    "easy" if overall_score >= 60 else \
                    "moderate" if overall_score >= 40 else \
                    "difficult" if overall_score >= 20 else "very difficult"

        # Find most impactful factors
        sorted_factors = sorted(factors, key=lambda f: f.score * f.weight)
        limiting_factors = [f.name for f in sorted_factors[:2]]

        return (f"Exploit is {difficulty} (score: {overall_score:.1f}/100). "
               f"Requires {skill_level.value.replace('_', ' ')} skill level and "
               f"approximately {time_to_exploit.value} to develop. "
               f"Primary limiting factors: {', '.join(limiting_factors)}.")


